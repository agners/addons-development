From b1f0232cc0aa739eabeffe705a9d6d51b97f4138 Mon Sep 17 00:00:00 2001
Message-Id: <b1f0232cc0aa739eabeffe705a9d6d51b97f4138.1660988317.git.stefan@agner.ch>
From: Stefan Agner <stefan@agner.ch>
Date: Sat, 20 Aug 2022 10:10:08 +0200
Subject: [PATCH] Use TCP socket instead of serial port

Instead of opening a serial port, open a TCP socket on port 9999. Pass
the listening socket to the new instance in case a controller reset is
being requested. This makes sure the TCP connection stays up even when
zigbeed restarts.
---
 app.c                                         |   3 +-
 .../zigbee/app/zigbeed/serial_adapter.c       | 120 +++++++++++++-----
 main.c                                        |   3 +
 3 files changed, 89 insertions(+), 37 deletions(-)

diff --git a/app.c b/app.c
index a907ee1..e3011c0 100644
--- a/app.c
+++ b/app.c
@@ -77,7 +77,6 @@ typedef struct PosixConfig{
 extern jmp_buf gResetJump;
 
 #define SERIAL_PORT_NAME_MAX_LEN 40
-extern char serialPort[SERIAL_PORT_NAME_MAX_LEN];
 #define RADIO_URL_MAX_LEN 150
 char radioUrl[RADIO_URL_MAX_LEN];
 
@@ -227,7 +226,7 @@ static void ParseArg(int aArgCount, char *aArgVector[], PosixConfig *aConfig)
           fprintf(stderr, "Error: ezsp-interface name too long\n");
           exit(OT_EXIT_INVALID_ARGUMENTS);
         }
-        strcpy(serialPort, optarg);
+        //strcpy(serialPort, optarg);
         break;
       case OT_POSIX_OPT_RADIO_URL:
         if (strlen(optarg) > RADIO_URL_MAX_LEN) {
diff --git a/gecko_sdk_4.1.1/protocol/zigbee/app/zigbeed/serial_adapter.c b/gecko_sdk_4.1.1/protocol/zigbee/app/zigbeed/serial_adapter.c
index f64ff63..4348d1f 100644
--- a/gecko_sdk_4.1.1/protocol/zigbee/app/zigbeed/serial_adapter.c
+++ b/gecko_sdk_4.1.1/protocol/zigbee/app/zigbeed/serial_adapter.c
@@ -17,13 +17,16 @@
  *
  ******************************************************************************/
 
-#include <stdint.h>
-#include <stdbool.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <netinet/in.h>
+#include <stdint.h>
+#include <stdbool.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
-#include <termios.h>
+#include <sys/socket.h>
+#include <netinet/tcp.h>
 #include <unistd.h>
 
 #include "ember-types.h"
@@ -37,14 +40,16 @@
 #define MAX_OUT_BLOCK_LEN     512   // maximum bytes to output at one time
 #define MAX_IN_BLOCK_LEN      512   // maximum bytes to input at one time
 
-#define DEFAULT_SERIAL_PORT "/tmp/ttyZigbeed"
 #define DEFAULT_OUT_BLOCK_LEN 1
 #define DEFAULT_IN_BLOCK_LEN 256
 #define SERIAL_PORT_NAME_MAX_LEN 40
 
-char serialPort[SERIAL_PORT_NAME_MAX_LEN] = DEFAULT_SERIAL_PORT;
+#define PORT 9999
+
+extern jmp_buf gResetJump;
+
+static int socketFd = -1;
 
-static int serialFd = NULL_FILE_DESCRIPTOR;   // file descriptor for serial port
 static uint8_t outBuffer[MAX_OUT_BLOCK_LEN];  // array to buffer output
 static uint8_t *outBufRd;                     // outBuffer read pointer
 static uint8_t *outBufWr;                     // outBuffer write pointer
@@ -54,13 +59,18 @@ static uint8_t *inBufRd;                      // inBuffer read pointer
 static uint8_t *inBufWr;                      // inBuffer write pointer
 static uint16_t inBlockLen;                   // bytes to read ahead
 
-static void serialClose(void)
+void serialClose(void)
 {
-  if (serialFd != NULL_FILE_DESCRIPTOR) {
-    tcflush(serialFd, TCIOFLUSH);
-    close(serialFd);
-    serialFd = NULL_FILE_DESCRIPTOR;
+  char buf[16];
+
+  if (socketFd > 0) {
+    snprintf(buf, sizeof(buf), "%d", socketFd);
+    setenv("ZIGBEED_SOCKET_FD", buf, true);
+  } else {
+    unsetenv("ZIGBEED_SOCKET_FD");
   }
+  //close(socketFd);
+  //socketFd = -1;
 }
 
 static void writeFlush(void)
@@ -68,11 +78,10 @@ static void writeFlush(void)
   int16_t count;
 
   if (outBufWr - outBufRd) {
-    count = write(serialFd, outBufRd, outBufWr - outBufRd);
+    count = write(socketFd, outBufRd, outBufWr - outBufRd);
     if (count > 0) {
       outBufRd += count;
     }
-    fsync(serialFd);
     if (outBufRd == outBufWr) {
       outBufRd = outBufWr = outBuffer;
     }
@@ -81,13 +90,20 @@ static void writeFlush(void)
 
 static EmberStatus readAvailable(uint16_t *count)
 {
-  int16_t bytesRead;
+  int bytesRead;
+
   if (inBufRd == inBufWr) {
     inBufRd = inBufWr = inBuffer;
-    bytesRead = read(serialFd, inBuffer, inBlockLen);
+    bytesRead = read(socketFd, inBuffer, inBlockLen);
     if (bytesRead > 0) {
       inBufWr += bytesRead;
     }
+    if (bytesRead == 0) {
+      fprintf(stderr, "Socket connection has been closed, restarting...\r\n");
+      close(socketFd);
+      socketFd = -1;
+      longjmp(gResetJump, 1);
+    }
   }
   *count = inBufWr - inBufRd;
   if (inBufRd == inBufWr) {
@@ -108,7 +124,12 @@ EmberStatus emberSerialInit(uint8_t port,
 #ifdef IO_LOG
   logFile = fopen(IO_LOG, "w");
 #endif
-  struct termios tios;
+  struct sockaddr_in address;
+  int addrlen = sizeof(address);
+  const char *env;
+  int opt = 1;
+  static int serverFd = -1;
+
   outBufRd = outBuffer;
   outBufWr = outBuffer;
   outBlockLen = DEFAULT_OUT_BLOCK_LEN;
@@ -122,36 +143,65 @@ EmberStatus emberSerialInit(uint8_t port,
     inBlockLen = MAX_IN_BLOCK_LEN;
   }
 
+  env = getenv("ZIGBEED_SOCKET_FD");
+  if (env && (socketFd = strtol(env, NULL, 10)) > 0) {
+    fprintf(stderr, "Using passed socket %d\r\n", socketFd);
+    return EMBER_SUCCESS;
+  }
+
   // Make sure any previous file descriptor is nicely closed.
   // This should only be necessary during a failure recovery when the
   // host encountered an error.
-  serialClose();
+  //serialClose();
 
-  serialFd = open(serialPort,
-                  O_RDWR | O_NOCTTY | O_NONBLOCK);
 
-  if (serialFd == NULL_FILE_DESCRIPTOR) {
-    fprintf(stderr, "Failed to open %s: %s\r\n", serialPort, strerror(errno));
-    fprintf(stderr, "Use socat to create PTYs for zigbeed and the host app. Eg:\r\n");
-    fprintf(stderr, "socat -x -v pty,link=/dev/ttyZigbeeNCP pty,link=/tmp/ttyZigbeeNCP\r\n");
+  if ((serverFd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+    fprintf(stderr, "Failed to create server socket: %s\r\n", strerror(errno));
     serialClose();
     return EMBER_ERR_FATAL;
   }
 
-  tcflush(serialFd, TCIOFLUSH);       // flush all input and output data
-  fcntl(serialFd, F_SETFL, O_NDELAY);
-  tcgetattr(serialFd, &tios);         // get current serial port options
+  // Forcefully attaching socket to the port 8080
+  if (setsockopt(serverFd, SOL_SOCKET,
+                 SO_REUSEADDR, &opt,
+                 sizeof(opt))) {
+    fprintf(stderr, "Failed to set server socket options: %s\r\n", strerror(errno));
+    serialClose();
+    return EMBER_ERR_FATAL;
+  }
 
-  tios.c_iflag &= ~(BRKINT | INLCR | IGNCR | ICRNL | INPCK
-                    | ISTRIP | IMAXBEL | IXON | IXOFF | IXANY);
+  address.sin_family = AF_INET;
+  address.sin_addr.s_addr = INADDR_ANY;
+  address.sin_port = htons(PORT);
 
-  tios.c_lflag &= ~(ICANON | ECHO | IEXTEN | ISIG);  // raw input
+  if (bind(serverFd, (struct sockaddr*)&address, sizeof(address)) < 0) {
+    fprintf(stderr, "Failed to bind server socket to port %d: %s\r\n", PORT, strerror(errno));
+    serialClose();
+    return EMBER_ERR_FATAL;
+  }
 
-  tios.c_oflag &= ~OPOST;               // raw output
+  fprintf(stderr, "Listening on port %d for connection...\r\n", PORT);
+  if (listen(serverFd, 3) < 0) {
+    fprintf(stderr, "Failed to listen on server socket: %s\r\n", strerror(errno));
+    serialClose();
+    return EMBER_ERR_FATAL;
+  }
+
+  fprintf(stderr, "Accepting connection.\r\n");
+  if ((socketFd = accept(serverFd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {
+    fprintf(stderr, "Failed to accept on server socket: %s\r\n", strerror(errno));
+    return EMBER_SERIAL_RX_EMPTY;
+  }
+  fprintf(stderr, "Accepted connection %d.\r\n", socketFd);
 
-  (void) memset(tios.c_cc, _POSIX_VDISABLE, NCCS);  // disable all control chars
+  close(serverFd);
 
-  tcsetattr(serialFd, TCSAFLUSH, &tios);  // set EZSP serial port options
+  fcntl(socketFd, F_SETFL, O_NONBLOCK);
+  if (setsockopt(socketFd, SOCK_STREAM,
+                 TCP_NODELAY, &opt,
+                 sizeof(opt))) {
+    fprintf(stderr, "Failed to set server socket options: %s\r\n", strerror(errno));
+  }
 
   return EMBER_SUCCESS;
 }
@@ -207,13 +257,13 @@ void sli_serial_adapter_tick_callback(void)
   FD_ZERO(&mainloop.mErrorFdSet);
 
   // Update mainloop initial FD and its timeout value
-  mainloop.mMaxFd           = serialFd;
+  mainloop.mMaxFd           = socketFd;
   mainloop.mTimeout.tv_sec  = timeoutMs / 1000;
   mainloop.mTimeout.tv_usec = (timeoutMs - mainloop.mTimeout.tv_sec * 1000) * 1000;
 
   // Update mainloop FDs to monitor
-  FD_SET(serialFd, &mainloop.mReadFdSet);
-  FD_SET(serialFd, &mainloop.mErrorFdSet);
+  FD_SET(socketFd, &mainloop.mReadFdSet);
+  FD_SET(socketFd, &mainloop.mErrorFdSet);
   otSysMainloopUpdate(NULL, &mainloop);
 
   if (otSysMainloopPoll(&mainloop) >= 0) {
diff --git a/main.c b/main.c
index 8ca0924..85c2574 100644
--- a/main.c
+++ b/main.c
@@ -49,6 +49,8 @@ void __gcov_flush();
 // From platform/base/phy/simulation/security.h:
 extern uint8_t simulatorEncryptionType;
 
+extern void serialClose(void);
+
 void app_init(void)
 {
 #if defined(EMBER_TEST)
@@ -92,6 +94,7 @@ int main(void)
   app_process_args(argc, argv);
 
   if (setjmp(gResetJump)) {
+    serialClose();
     fprintf(stderr, "Restarting\n");
     execvp(argv[0], argv);
   }
-- 
2.37.2

